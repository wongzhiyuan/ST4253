---
title: "Tutorial 9"
author: "Bharath S"
date: "2023-11-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load necessary libraries
library(fpp3)
library(tidyverse)
install.packages('imputeTS')
library(imputeTS)
library(zoo)
library(forecast)
library(tsibble)
```

```{r - Utility fxns} 
generate_arima_tsibble <- function(n, order, ar, ma, sd_noise) {
    # n: number of observations
    # order: order of the ARIMA model (p, d, q)
    # ar: auto-regressive parameters (vector)
    # ma: moving average parameters (vector)
    # sd_noise: standard deviation of the noise
    
    # Check and set AR and MA parameters based on order
    model_list <- list(order = order, sd = sd_noise)
    if (order[1] > 0) model_list$ar <- ar  # Include AR parameters if p > 0
    if (order[3] > 0) model_list$ma <- ma  # Include MA parameters if q > 0

    # Generate the ARIMA time series
    arima_series <- arima.sim(n = n, model = model_list)
    
    # Create a tsibble from the generated time series
    arima_tsibble <- as_tsibble(ts(arima_series))
    
    return(arima_tsibble)
}
```

```{r}
drop_observations <- function(ts_data, fraction, mode = "random", period = NULL) {
    # ts_data: A tsibble with the time series data
    # fraction: Fraction of the observations to drop
    # mode: The mode of dropping observations - "random", "seasonal", or "chunked"
    
    # Calculate the number of observations to drop
    num_to_drop <- round(fraction * nrow(ts_data))
    
    # Drop observations based on the specified mode
    if (mode == "random") {
        # Randomly select indices to drop
        set.seed(123) # For reproducibility
        drop_indices <- sample(nrow(ts_data), num_to_drop)
        ts_data[drop_indices, "value"] <- NA
    } else if (mode == "seasonal") {
        if (is.null(period)) {
            stop("For seasonal dropping, 'period' must be specified.")
        }
        # Compute indices based on seasonality
        seasons <- rep(1:period, length.out = nrow(ts_data))
        selected_seasons <- sample(1:period, num_to_drop, replace = TRUE)
        drop_indices <- which(seasons %in% selected_seasons)
        ts_data[drop_indices, "value"] <- NA
    } else if (mode == "chunked") {
        # Compute indices to drop in chunks
        chunk_size <- max(1, num_to_drop) # Ensure at least one observation is dropped
        total_chunks <- ceiling(nrow(ts_data) / chunk_size)
        selected_chunk_start <- sample(nrow(ts_data), total_chunks, replace = FALSE)
        for (start in selected_chunk_start) {
            end <- min(nrow(ts_data), start + chunk_size - 1)
            ts_data[start:end, "value"] <- NA
            num_to_drop <- num_to_drop - (end - start + 1)
            if (num_to_drop <= 0) break
        }
    } else {
        stop("Unknown mode specified. Use 'random', 'seasonal', or 'chunked'.")
    }
    
    return(ts_data)
}
```

```{r}
estimate_arima_params <- function(ts_data) {
  auto_fit <- auto.arima(ts_data)
  
  # Extract AR and MA parameters
  ar_params <- auto_fit$coef[paste0("ar", seq(auto_fit$arma[1]))]
  ma_params <- auto_fit$coef[paste0("ma", seq(auto_fit$arma[2]))]

  return(list(order = auto_fit$arma[1:3], ar = ar_params, ma = ma_params))
}

compute_forecast_horizon <- function(ts_data, order, ar, ma, h) {
  model <- Arima(ts_data$value, order = order, )
  forecast_horizon <- forecast(model, h = h)
  return(forecast_horizon)
}

arima_forecast_framework <- function(datasets, order, ar, ma, h) {
  results <- list()
  
  for (i in seq_along(datasets)) {
    dataset <- datasets[[i]]
    
    # Compute forecast using true parameters
    forecast_true_params <- compute_forecast_horizon(dataset, order, ar, ma, h)
    
    # Estimate parameters and compute forecast
    estimated_params <- estimate_arima_params(dataset)
    forecast_estimated_params <- compute_forecast_horizon(dataset, estimated_params$order, estimated_params$ar, estimated_params$ma, h)
    
    # Store the results
    results[[i]] <- list(forecast_true_params = forecast_true_params,
                         forecast_estimated_params = forecast_estimated_params,
                         estimated_params = estimated_params)
  }
  
  return(results)
}
```

```{r interpolation}
interpolation <- function(ts_data, method = c("linear", "cubic")) {
  # Convert tsibble to zoo object
  zoo_data <- zoo(ts_data$value, order.by = ts_data$index)
  
  # Perform interpolation based on the specified method
  if (method == "linear") {
    interpolated_values <- na.approx(zoo_data)
  } else if (method == "cubic") {
    interpolated_values <- na.spline(zoo_data)
  } else {
    stop("Invalid interpolation method. Supported methods: 'linear', 'cubic'")
  }

  # Extract values and index from zoo object
  interpolated_data <- data.frame(index = index(interpolated_values), value = coredata(interpolated_values))

  # Convert back to tsibble manually
  tsibble_data_filled <- tsibble(index = interpolated_data$index, value = interpolated_data$value)

  return(tsibble_data_filled)
}
```

```{r}
calculate_mse_fc <- function(forecast_results) {
    mse_vector <- numeric(length(forecast_results))
    
    for (i in seq_along(forecast_results)) {
        estimated_forecast <- forecast_results[[i]]$forecast_estimated_params$mean
        true_forecast <- forecast_results[[i]]$forecast_true_params$mean
        mse_vector[i] <- mean((estimated_forecast - true_forecast)^2)
    }
    
    return(mse_vector)
}
```

```{r}
# TS Params
n <- 100  # Number of observations
order <- c(1, 1, 1)  # ARIMA order (p, d, q)
ar_param <- 0.5  # AR parameter
ma_param <- 0.7  # MA parameter
sd_noise <- 1  # Standard deviation of noise
```

```{r}
# 1. Generate an ARIMA Time Series
arima_ts <- generate_arima_tsibble(n, order, ar_param, ma_param, sd_noise)
```

```{r}
# 2. Introduce Missing Observations
fraction_missing <- 0.1  # Fraction of data to be dropped
modified_ts <- drop_observations(arima_ts, fraction_missing)
seasonally_modified_ts<-drop_observations(arima_ts, fraction_missing/12,'seasonal',4)
chunked_modified_ts<-drop_observations(arima_ts, fraction_missing,'chunked')
```

```{r}
# 3. Impute Missing Data
# Imputing by weighted moving average, LOCF, NOCB
ma_ts<- ma_impute(modified_ts)

locf_ts <- modified_ts %>%
  mutate(value = ifelse(is.na(value),
  na_locf(value), value))

nocb_ts <- modified_ts %>%
  mutate(value = ifelse(is.na(value),
  na_locf(value, option = "nocb"), value))

# Impute seasonally modified ts with weighted moving average, LOCF, NOCB
ma_seas_ts <- na_ma(seasonally_modified_ts)

locf_seas_ts <- seasonally_modified_ts %>%
  mutate(value = ifelse(is.na(value),
  na_locf(value), value))

nocb_seas_ts <- seasonally_modified_ts %>%
  mutate(value = ifelse(is.na(value),
  na_locf(value, option = "nocb"), value))

# Impute chunked modified ts with WMA, LOCF, NOCB
ma_chunked_ts <- ma_impute(chunked_modified_ts)

locf_chunked_ts <- chunked_modified_ts %>%
  mutate(value = ifelse(is.na(value),
  na_locf(value), value))

nocb_chunked_ts <- chunked_modified_ts %>%
  mutate(value = ifelse(is.na(value),
  na_locf(value, option = "nocb"), value))


# After splitting time series into seasons, perform imputation using MA, LOCF, NOCB
na_seasplit(modified_ts,algorithm ='ma')
#na_seasplit(modified_ts,algorithm = "locf")

# After removing seasonal component, perform imputation using MA
na_seadec(modified_ts,algorithm ='ma')
#na_seadec(modified_ts,algorithm = "locf")
```

```{r}
# 3. Impute Missing Data
mean_value <- mean(modified_ts$value, na.rm = TRUE)
modified_ts$value[is.na(modified_ts$value)] <- mean_value
```

```{r}
# 4. Estimate ARIMA Parameters on the Modified Data
estimated_params <- estimate_arima_params(modified_ts$value)

# 5. Forecasting
forecast_horizon <- 10  # Forecast horizon
datasets <- list(arima_ts, modified_ts)  # List of original and modified datasets

# Apply the forecasting framework
forecast_results <- arima_forecast_framework(datasets, order, ar_param, ma_param, forecast_horizon)

# Display the results
print(forecast_results)
```

```{r}
calculate_mse_fc(forecast_results)
```
